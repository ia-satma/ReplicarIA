Necesito que completes la optimizaci√≥n final del sistema. Ejecuta estas tareas EN ORDEN, una por una, y confirma cada paso antes de continuar.

## TAREA 1: EJECUTAR MIGRACI√ìN DE EMBEDDINGS

El RAG sem√°ntico no funciona sin embeddings. Ejecuta:
```bash
# Primero verificar estado actual
python -c "
import asyncio
import asyncpg
import os

async def check():
    conn = await asyncpg.connect(os.getenv('DATABASE_URL'))
    total = await conn.fetchval('SELECT COUNT(*) FROM knowledge_chunks')
    with_emb = await conn.fetchval('SELECT COUNT(*) FROM knowledge_chunks WHERE embedding IS NOT NULL')
    print(f'Total chunks: {total}')
    print(f'Con embedding: {with_emb}')
    print(f'Sin embedding: {total - with_emb}')
    await conn.close()

asyncio.run(check())
"
```

Si hay chunks sin embedding, ejecutar:
```bash
python -m scripts.migrate_embeddings
```

Confirma: ¬øCu√°ntos chunks tienen embedding ahora?

---

## TAREA 2: CREAR √çNDICES POSTGRESQL FALTANTES

Ejecuta este SQL en la base de datos:
```sql
-- √çndice para b√∫squeda de proyectos
CREATE INDEX IF NOT EXISTS idx_projects_empresa_estado_fecha 
ON projects(empresa_id, estado, created_at DESC);

-- √çndice para deliberaciones recientes
CREATE INDEX IF NOT EXISTS idx_deliberations_project_created 
ON deliberations(project_id, created_at DESC);

-- √çndice para chunks con embedding
CREATE INDEX IF NOT EXISTS idx_chunks_with_embedding 
ON knowledge_chunks(empresa_id) 
WHERE embedding IS NOT NULL;

-- √çndice para usage tracking
CREATE INDEX IF NOT EXISTS idx_usage_empresa_fecha_desc 
ON usage_tracking(empresa_id, fecha DESC);

-- Actualizar estad√≠sticas
ANALYZE projects;
ANALYZE deliberations;
ANALYZE knowledge_chunks;
ANALYZE usage_tracking;
```

Confirma: ¬øSe crearon los √≠ndices sin errores?

---

## TAREA 3: ELIMINAR MONGODB COMPLETAMENTE

3.1 Verificar si hay referencias a MongoDB:
```bash
grep -rn "motor\|mongo\|Motor\|Mongo\|MONGO" backend/ --include="*.py" | grep -v __pycache__ | grep -v ".pyc"
```

3.2 Si encuentra referencias, elim√≠nalas de esos archivos.

3.3 Verificar requirements.txt:
```bash
grep -E "motor|pymongo" requirements.txt
```

3.4 Si encuentra motor o pymongo, elim√≠nalos de requirements.txt.

3.5 Verificar Secrets en Replit:
- Si existe MONGO_URI o MONGODB_URI, elim√≠nalos de Secrets.

Confirma: ¬øSe eliminaron todas las referencias a MongoDB?

---

## TAREA 4: IMPLEMENTAR REDIS CACHE (OPCIONAL PERO RECOMENDADO)

4.1 Si el usuario tiene cuenta en Upstash, agregar REDIS_URL a Secrets.

4.2 Instalar redis:
```bash
pip install redis --break-system-packages
```

4.3 Crear archivo backend/services/cache_service.py:
```python
"""
Servicio de Cache con Redis.
"""
import redis
import json
import os
from typing import Optional, Any
from functools import wraps
import hashlib

REDIS_URL = os.getenv("REDIS_URL")

class CacheService:
    def __init__(self):
        if REDIS_URL:
            self.client = redis.from_url(REDIS_URL, decode_responses=True)
            self.enabled = True
        else:
            self.client = None
            self.enabled = False
    
    def get(self, key: str) -> Optional[Any]:
        if not self.enabled:
            return None
        try:
            value = self.client.get(key)
            return json.loads(value) if value else None
        except:
            return None
    
    def set(self, key: str, value: Any, ttl: int = 300) -> bool:
        if not self.enabled:
            return False
        try:
            self.client.setex(key, ttl, json.dumps(value))
            return True
        except:
            return False
    
    def delete_pattern(self, pattern: str) -> int:
        if not self.enabled:
            return 0
        try:
            keys = self.client.keys(pattern)
            return self.client.delete(*keys) if keys else 0
        except:
            return 0

_cache = None

def get_cache() -> CacheService:
    global _cache
    if _cache is None:
        _cache = CacheService()
    return _cache
```

Confirma: ¬øSe cre√≥ el archivo de cache?

---

## TAREA 5: CREAR SCRIPT DE HEALTH CHECK

Crear archivo backend/scripts/health_check.py:
```python
"""
Health check del sistema.
"""
import asyncio
import asyncpg
import os
from datetime import datetime

async def main():
    print("=" * 50)
    print(f"HEALTH CHECK - {datetime.now().isoformat()}")
    print("=" * 50)
    
    try:
        conn = await asyncpg.connect(os.getenv("DATABASE_URL"))
        
        # Tablas cr√≠ticas
        tables = ['empresas', 'users', 'projects', 'deliberations', 
                  'knowledge_chunks', 'usage_tracking', 'planes']
        
        print("\nüìä TABLAS:")
        for table in tables:
            try:
                count = await conn.fetchval(f"SELECT COUNT(*) FROM {table}")
                print(f"  ‚úÖ {table}: {count} rows")
            except:
                print(f"  ‚ùå {table}: ERROR")
        
        # pgvector
        has_vector = await conn.fetchval(
            "SELECT EXISTS (SELECT 1 FROM pg_extension WHERE extname = 'vector')"
        )
        print(f"\nüîç PGVECTOR: {'‚úÖ Instalado' if has_vector else '‚ùå Falta'}")
        
        # Embeddings
        total = await conn.fetchval("SELECT COUNT(*) FROM knowledge_chunks")
        with_emb = await conn.fetchval(
            "SELECT COUNT(*) FROM knowledge_chunks WHERE embedding IS NOT NULL"
        )
        pct = (with_emb / total * 100) if total > 0 else 0
        status = "‚úÖ" if pct > 80 else "‚ö†Ô∏è" if pct > 50 else "‚ùå"
        print(f"\nüìà EMBEDDINGS: {status} {with_emb}/{total} ({pct:.1f}%)")
        
        # Planes
        planes = await conn.fetchval("SELECT COUNT(*) FROM planes")
        print(f"\nüí∞ PLANES: {'‚úÖ' if planes >= 4 else '‚ùå'} {planes} configurados")
        
        await conn.close()
        print("\n" + "=" * 50)
        print("‚úÖ HEALTH CHECK COMPLETADO")
        
    except Exception as e:
        print(f"\n‚ùå ERROR: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```

Ejecuta el health check:
```bash
python backend/scripts/health_check.py
```

Confirma: ¬øQu√© resultado muestra el health check?

---

## TAREA 6: ELIMINAR ARCHIVO LEGACY DEL CHATBOT

6.1 Verificar que el refactorizado est√° activo:
```bash
grep "ChatbotArchivoRefactored" frontend/src/App.js
```

6.2 Si est√° activo, mover el original a deprecated:
```bash
mkdir -p frontend/src/components/_deprecated
mv frontend/src/components/ChatbotArchivo.jsx frontend/src/components/_deprecated/ 2>/dev/null || echo "Ya movido o no existe"
```

6.3 Verificar que la app sigue funcionando (iniciar y probar /onboarding)

Confirma: ¬øEl chatbot funciona correctamente?

---

## TAREA 7: VERIFICACI√ìN FINAL

Ejecuta esta verificaci√≥n completa:
```bash
echo "=== VERIFICACI√ìN FINAL ==="

echo -e "\n1. MongoDB eliminado:"
count=$(grep -rn "motor\|mongo" backend/ --include="*.py" 2>/dev/null | grep -v __pycache__ | wc -l)
if [ "$count" -eq "0" ]; then echo "‚úÖ Sin referencias a MongoDB"; else echo "‚ùå $count referencias encontradas"; fi

echo -e "\n2. Componente refactorizado activo:"
grep -q "ChatbotArchivoRefactored" frontend/src/App.js && echo "‚úÖ ChatbotArchivoRefactored activo" || echo "‚ùå No activo"

echo -e "\n3. Rutas registradas en server.py:"
routes=$(grep -c "include_router" backend/server.py)
echo "‚úÖ $routes routers registrados"

echo -e "\n4. Health check:"
python backend/scripts/health_check.py

echo -e "\n=== FIN VERIFICACI√ìN ==="
```

---

## RESUMEN DE TAREAS

| # | Tarea | Cr√≠tica |
|---|-------|---------|
| 1 | Migrar embeddings | ‚úÖ S√ç - RAG no funciona sin esto |
| 2 | Crear √≠ndices PostgreSQL | ‚úÖ S√ç - Performance |
| 3 | Eliminar MongoDB | ‚úÖ S√ç - Simplificar |
| 4 | Implementar Redis cache | ‚ö†Ô∏è OPCIONAL |
| 5 | Crear health check | ‚úÖ S√ç - Monitoreo |
| 6 | Eliminar legacy chatbot | ‚ö†Ô∏è OPCIONAL |
| 7 | Verificaci√≥n final | ‚úÖ S√ç |

Ejecuta las tareas 1-3, 5 y 7 como m√≠nimo. Las tareas 4 y 6 son opcionales pero recomendadas.

Dame un reporte despu√©s de cada tarea con el resultado.
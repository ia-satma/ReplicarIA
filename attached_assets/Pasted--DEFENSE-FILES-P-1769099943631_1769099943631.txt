â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ DEFENSE FILES - PARTE 1: ESTRUCTURA Y SERVICIO BASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OBJETIVO: Crear sistema para documentar TODA evidencia que sustente
la posiciÃ³n fiscal del contribuyente ante observaciones del SAT.

Â¿QUÃ‰ SE DOCUMENTA?
â€¢ Cada conversaciÃ³n con cada agente IA
â€¢ Cada CFDI analizado (proveedor, monto, concepto)
â€¢ Cada documento consultado del RAG
â€¢ Cada email enviado/recibido
â€¢ Cada cÃ¡lculo realizado
â€¢ Cada alerta generada
â€¢ Cada decisiÃ³n tomada con su justificaciÃ³n
â€¢ Timestamps, usuarios, hashes de integridad

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ESTRUCTURA DE CARPETAS EN pCLOUD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

```
pCloud/
â””â”€â”€ SATMA/
    â””â”€â”€ Defense_Files/
        â””â”€â”€ {RFC_Cliente}/
            â””â”€â”€ {AÃ±o_Fiscal}/
                â””â”€â”€ {Entregable_ID}_{Nombre}/
                    â”‚
                    â”œâ”€â”€ ğŸ“ 01_Expediente/
                    â”‚   â”œâ”€â”€ caratula.json              # Info general del caso
                    â”‚   â”œâ”€â”€ timeline_maestro.json      # CronologÃ­a completa
                    â”‚   â”œâ”€â”€ participantes.json         # QuiÃ©n hizo quÃ©
                    â”‚   â””â”€â”€ resumen_ejecutivo.md       # Para humanos
                    â”‚
                    â”œâ”€â”€ ğŸ“ 02_Proveedores/
                    â”‚   â”œâ”€â”€ {RFC_Proveedor}/
                    â”‚   â”‚   â”œâ”€â”€ perfil.json            # Datos del proveedor
                    â”‚   â”‚   â”œâ”€â”€ verificacion_69b.json  # Status lista negra
                    â”‚   â”‚   â”œâ”€â”€ verificacion_efos.json # EFOS check
                    â”‚   â”‚   â”œâ”€â”€ cfdis/
                    â”‚   â”‚   â”‚   â””â”€â”€ {UUID}.json        # Cada factura
                    â”‚   â”‚   â””â”€â”€ evidencia_comercial/   # Contratos, pagos, etc.
                    â”‚   â””â”€â”€ resumen_proveedores.json
                    â”‚
                    â”œâ”€â”€ ğŸ“ 03_CFDIs/
                    â”‚   â”œâ”€â”€ recibidos/
                    â”‚   â”‚   â””â”€â”€ {UUID}.json
                    â”‚   â”œâ”€â”€ emitidos/
                    â”‚   â”‚   â””â”€â”€ {UUID}.json
                    â”‚   â”œâ”€â”€ analisis_global.json
                    â”‚   â””â”€â”€ inconsistencias.json
                    â”‚
                    â”œâ”€â”€ ğŸ“ 04_Deducciones/
                    â”‚   â”œâ”€â”€ {Concepto}/
                    â”‚   â”‚   â”œâ”€â”€ calculo.json
                    â”‚   â”‚   â”œâ”€â”€ fundamento_legal.json
                    â”‚   â”‚   â”œâ”€â”€ documentos_soporte/
                    â”‚   â”‚   â””â”€â”€ justificacion_ia.json
                    â”‚   â””â”€â”€ resumen_deducciones.json
                    â”‚
                    â”œâ”€â”€ ğŸ“ 05_Agentes_IA/
                    â”‚   â”œâ”€â”€ A1_Facturar/
                    â”‚   â”‚   â”œâ”€â”€ conversaciones/
                    â”‚   â”‚   â”œâ”€â”€ analisis/
                    â”‚   â”‚   â””â”€â”€ bitacora.json
                    â”‚   â”œâ”€â”€ A2_Bibliotecar/
                    â”‚   â”‚   â”œâ”€â”€ consultas_rag/
                    â”‚   â”‚   â”œâ”€â”€ documentos_citados/
                    â”‚   â”‚   â””â”€â”€ bitacora.json
                    â”‚   â”œâ”€â”€ A3_Revisar/
                    â”‚   â”‚   â”œâ”€â”€ revisiones/
                    â”‚   â”‚   â”œâ”€â”€ hallazgos/
                    â”‚   â”‚   â””â”€â”€ bitacora.json
                    â”‚   â””â”€â”€ ... (demÃ¡s agentes)
                    â”‚
                    â”œâ”€â”€ ğŸ“ 06_Comunicaciones/
                    â”‚   â”œâ”€â”€ emails_enviados/
                    â”‚   â”œâ”€â”€ emails_recibidos/
                    â”‚   â”œâ”€â”€ notificaciones_sat/
                    â”‚   â””â”€â”€ bitacora_comunicaciones.json
                    â”‚
                    â”œâ”€â”€ ğŸ“ 07_Calculos/
                    â”‚   â”œâ”€â”€ isr/
                    â”‚   â”œâ”€â”€ iva/
                    â”‚   â”œâ”€â”€ ajustes/
                    â”‚   â””â”€â”€ conciliaciones/
                    â”‚
                    â”œâ”€â”€ ğŸ“ 08_Marco_Legal/
                    â”‚   â”œâ”€â”€ articulos_aplicables/
                    â”‚   â”œâ”€â”€ jurisprudencias_citadas/
                    â”‚   â”œâ”€â”€ criterios_sat/
                    â”‚   â””â”€â”€ fundamentos.json
                    â”‚
                    â”œâ”€â”€ ğŸ“ 09_Evidencia_Soporte/
                    â”‚   â”œâ”€â”€ contratos/
                    â”‚   â”œâ”€â”€ estados_cuenta/
                    â”‚   â”œâ”€â”€ comprobantes_pago/
                    â”‚   â”œâ”€â”€ acuses/
                    â”‚   â””â”€â”€ otros/
                    â”‚
                    â””â”€â”€ ğŸ“ 10_Defense_File_Final/
                        â”œâ”€â”€ indice_evidencias.xlsx
                        â”œâ”€â”€ defense_file_v{N}.pdf
                        â”œâ”€â”€ anexos/
                        â””â”€â”€ checksums.sha256
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FASE 1: TABLAS DE BASE DE DATOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TABLA PRINCIPAL: DEFENSE FILES (EXPEDIENTES)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE IF NOT EXISTS defense_files (
    id SERIAL PRIMARY KEY,
    
    -- IdentificaciÃ³n
    cliente_id INTEGER REFERENCES clientes(id),
    entregable_id INTEGER,  -- Referencia al proyecto/entregable
    
    -- Datos del caso
    nombre VARCHAR(255) NOT NULL,
    descripcion TEXT,
    aÃ±o_fiscal INTEGER NOT NULL,
    periodo_inicio DATE,
    periodo_fin DATE,
    
    -- Status
    estado VARCHAR(50) DEFAULT 'en_proceso',  -- en_proceso, revision, cerrado
    
    -- pCloud
    pcloud_path TEXT,  -- Ruta en pCloud
    pcloud_folder_id BIGINT,
    
    -- Metadata
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    cerrado_at TIMESTAMP,
    
    -- Integridad
    hash_contenido VARCHAR(64)  -- SHA256 del contenido al cerrar
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TABLA: EVENTOS DEL DEFENSE FILE (BITÃCORA MAESTRA)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE IF NOT EXISTS df_eventos (
    id SERIAL PRIMARY KEY,
    defense_file_id INTEGER REFERENCES defense_files(id) ON DELETE CASCADE,
    
    -- IdentificaciÃ³n del evento
    tipo VARCHAR(50) NOT NULL,  -- conversacion, analisis_cfdi, consulta_rag, email, calculo, alerta
    subtipo VARCHAR(50),        -- especÃ­fico segÃºn tipo
    agente VARCHAR(20),         -- A1, A2, A3, etc.
    
    -- QuiÃ©n y cuÃ¡ndo
    usuario_id INTEGER REFERENCES users(id),
    usuario_email VARCHAR(255),
    timestamp TIMESTAMP DEFAULT NOW(),
    
    -- Contenido
    titulo VARCHAR(255),
    descripcion TEXT,
    datos JSONB NOT NULL DEFAULT '{}',
    
    -- Archivos asociados
    archivos JSONB DEFAULT '[]',  -- [{nombre, path, hash, size}]
    
    -- Integridad
    hash_evento VARCHAR(64),  -- SHA256 del evento
    evento_anterior_hash VARCHAR(64),  -- Para cadena de integridad
    
    -- Ãndices para bÃºsqueda
    tags TEXT[],
    
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_df_eventos_defense_file ON df_eventos(defense_file_id);
CREATE INDEX idx_df_eventos_tipo ON df_eventos(tipo);
CREATE INDEX idx_df_eventos_agente ON df_eventos(agente);
CREATE INDEX idx_df_eventos_timestamp ON df_eventos(timestamp);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TABLA: PROVEEDORES DEL DEFENSE FILE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE IF NOT EXISTS df_proveedores (
    id SERIAL PRIMARY KEY,
    defense_file_id INTEGER REFERENCES defense_files(id) ON DELETE CASCADE,
    
    -- Datos del proveedor
    rfc VARCHAR(13) NOT NULL,
    razon_social VARCHAR(255),
    nombre_comercial VARCHAR(255),
    
    -- Verificaciones
    lista_69b_status VARCHAR(20),  -- limpio, publicado, presunto, definitivo
    lista_69b_fecha DATE,
    efos_status VARCHAR(20),
    efos_fecha DATE,
    opinion_cumplimiento VARCHAR(20),  -- positiva, negativa, sin_opinion
    opinion_fecha DATE,
    
    -- Totales
    total_cfdis INTEGER DEFAULT 0,
    monto_total DECIMAL(15,2) DEFAULT 0,
    iva_total DECIMAL(15,2) DEFAULT 0,
    
    -- Riesgo
    nivel_riesgo VARCHAR(20),  -- bajo, medio, alto, critico
    notas_riesgo TEXT,
    
    -- pCloud path
    pcloud_path TEXT,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(defense_file_id, rfc)
);

CREATE INDEX idx_df_proveedores_rfc ON df_proveedores(rfc);
CREATE INDEX idx_df_proveedores_riesgo ON df_proveedores(nivel_riesgo);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TABLA: CFDIs DEL DEFENSE FILE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE IF NOT EXISTS df_cfdis (
    id SERIAL PRIMARY KEY,
    defense_file_id INTEGER REFERENCES defense_files(id) ON DELETE CASCADE,
    proveedor_id INTEGER REFERENCES df_proveedores(id),
    
    -- IdentificaciÃ³n CFDI
    uuid VARCHAR(36) UNIQUE NOT NULL,
    serie VARCHAR(25),
    folio VARCHAR(40),
    
    -- Datos fiscales
    emisor_rfc VARCHAR(13),
    emisor_nombre VARCHAR(255),
    receptor_rfc VARCHAR(13),
    receptor_nombre VARCHAR(255),
    
    -- Montos
    subtotal DECIMAL(15,2),
    descuento DECIMAL(15,2) DEFAULT 0,
    iva DECIMAL(15,2) DEFAULT 0,
    isr_retenido DECIMAL(15,2) DEFAULT 0,
    iva_retenido DECIMAL(15,2) DEFAULT 0,
    total DECIMAL(15,2),
    
    -- Fechas
    fecha_emision TIMESTAMP,
    fecha_timbrado TIMESTAMP,
    fecha_pago DATE,
    
    -- Tipo
    tipo_comprobante VARCHAR(10),  -- I=Ingreso, E=Egreso, T=Traslado, P=Pago, N=NÃ³mina
    metodo_pago VARCHAR(3),
    forma_pago VARCHAR(2),
    uso_cfdi VARCHAR(10),
    
    -- ValidaciÃ³n
    status_sat VARCHAR(20),  -- vigente, cancelado, no_encontrado
    fecha_validacion TIMESTAMP,
    
    -- AnÃ¡lisis IA
    categoria_deduccion VARCHAR(100),
    es_deducible BOOLEAN,
    justificacion_deduccion TEXT,
    
    -- Riesgo
    alertas JSONB DEFAULT '[]',
    nivel_riesgo VARCHAR(20),
    
    -- Archivos
    xml_path TEXT,
    pdf_path TEXT,
    
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_df_cfdis_uuid ON df_cfdis(uuid);
CREATE INDEX idx_df_cfdis_emisor ON df_cfdis(emisor_rfc);
CREATE INDEX idx_df_cfdis_fecha ON df_cfdis(fecha_emision);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TABLA: DOCUMENTOS LEGALES CITADOS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE IF NOT EXISTS df_fundamentos (
    id SERIAL PRIMARY KEY,
    defense_file_id INTEGER REFERENCES defense_files(id) ON DELETE CASCADE,
    
    -- Tipo de fundamento
    tipo VARCHAR(50),  -- ley, reglamento, rmf, jurisprudencia, criterio_sat
    
    -- IdentificaciÃ³n
    documento VARCHAR(255),  -- CFF, LISR, RMF 2024, etc.
    articulo VARCHAR(50),
    fraccion VARCHAR(20),
    parrafo VARCHAR(20),
    
    -- Contenido
    titulo VARCHAR(255),
    texto_relevante TEXT,
    
    -- AplicaciÃ³n
    aplicacion TEXT,  -- CÃ³mo aplica al caso
    usado_en_eventos INTEGER[],  -- IDs de eventos donde se citÃ³
    
    -- Fuente
    kb_documento_id INTEGER REFERENCES kb_documentos(id),
    kb_chunk_ids INTEGER[],
    
    created_at TIMESTAMP DEFAULT NOW()
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TABLA: CÃLCULOS Y DETERMINACIONES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE TABLE IF NOT EXISTS df_calculos (
    id SERIAL PRIMARY KEY,
    defense_file_id INTEGER REFERENCES defense_files(id) ON DELETE CASCADE,
    
    -- Tipo de cÃ¡lculo
    tipo VARCHAR(50),  -- isr_mensual, iva_mensual, ajuste_anual, etc.
    periodo VARCHAR(20),  -- 2024-01, 2024-Q1, 2024-ANUAL
    
    -- Valores
    concepto VARCHAR(255),
    base_gravable DECIMAL(15,2),
    tasa DECIMAL(5,4),
    impuesto_calculado DECIMAL(15,2),
    
    -- Detalles
    formula_aplicada TEXT,
    datos_entrada JSONB,
    resultado JSONB,
    
    -- JustificaciÃ³n
    fundamento_legal TEXT,
    notas TEXT,
    
    -- QuiÃ©n lo hizo
    calculado_por VARCHAR(50),  -- agente o usuario
    revisado_por INTEGER REFERENCES users(id),
    
    created_at TIMESTAMP DEFAULT NOW()
);

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VISTA: TIMELINE COMPLETO
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE VIEW v_defense_timeline AS
SELECT 
    df.id as defense_file_id,
    df.nombre as caso,
    e.id as evento_id,
    e.timestamp,
    e.tipo,
    e.subtipo,
    e.agente,
    e.usuario_email,
    e.titulo,
    e.descripcion,
    e.hash_evento
FROM defense_files df
JOIN df_eventos e ON e.defense_file_id = df.id
ORDER BY df.id, e.timestamp;
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FASE 2: SERVICIO BASE DE DEFENSE FILES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Crear: backend/services/defense_files/defense_service.py

```python
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DEFENSE FILES - SERVICIO PRINCIPAL
Gestiona la creaciÃ³n y documentaciÃ³n de expedientes de defensa fiscal
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import os
import json
import hashlib
from datetime import datetime
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, asdict
from enum import Enum

from extensions import db
from sqlalchemy import text


class TipoEvento(Enum):
    # Interacciones con agentes
    CONVERSACION = 'conversacion'
    CONSULTA_RAG = 'consulta_rag'
    ANALISIS_IA = 'analisis_ia'
    
    # CFDIs y proveedores
    CFDI_REGISTRADO = 'cfdi_registrado'
    CFDI_VALIDADO = 'cfdi_validado'
    PROVEEDOR_VERIFICADO = 'proveedor_verificado'
    
    # Comunicaciones
    EMAIL_ENVIADO = 'email_enviado'
    EMAIL_RECIBIDO = 'email_recibido'
    NOTIFICACION = 'notificacion'
    
    # CÃ¡lculos y anÃ¡lisis
    CALCULO_REALIZADO = 'calculo_realizado'
    DEDUCCION_ANALIZADA = 'deduccion_analizada'
    
    # Documentos
    DOCUMENTO_SUBIDO = 'documento_subido'
    DOCUMENTO_CITADO = 'documento_citado'
    
    # Sistema
    ALERTA_GENERADA = 'alerta_generada'
    REVISION_COMPLETADA = 'revision_completada'


class Agente(Enum):
    A1_FACTURAR = 'A1'
    A2_BIBLIOTECAR = 'A2'
    A3_REVISAR = 'A3'
    A4_TRAFICO = 'A4'
    A5_DISENAR = 'A5'
    A6_ONBOARDING = 'A6'
    A7_DIAGNOSTICO = 'A7'
    SISTEMA = 'SYS'
    USUARIO = 'USR'


@dataclass
class Evento:
    tipo: TipoEvento
    agente: Agente
    titulo: str
    descripcion: str
    datos: Dict[str, Any]
    usuario_email: Optional[str] = None
    subtipo: Optional[str] = None
    archivos: List[Dict] = None
    tags: List[str] = None


class DefenseFileService:
    """Servicio principal para gestiÃ³n de Defense Files"""
    
    def __init__(self):
        self.pcloud = None  # Se inicializa si hay credenciales
        self._init_pcloud()
    
    def _init_pcloud(self):
        """Inicializa conexiÃ³n a pCloud si hay credenciales"""
        token = os.environ.get('PCLOUD_ACCESS_TOKEN')
        if token:
            from services.defense_files.pcloud_service import PCloudService
            self.pcloud = PCloudService()
            print("âœ… pCloud conectado para Defense Files")
        else:
            print("âš ï¸ PCLOUD_ACCESS_TOKEN no configurado - Defense Files solo en BD")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # GESTIÃ“N DE DEFENSE FILES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def crear_defense_file(self, 
                           cliente_id: int,
                           nombre: str,
                           aÃ±o_fiscal: int,
                           descripcion: str = None,
                           entregable_id: int = None,
                           periodo_inicio: str = None,
                           periodo_fin: str = None,
                           usuario_id: int = None) -> Dict:
        """Crea un nuevo Defense File"""
        
        try:
            # Obtener datos del cliente
            cliente = db.session.execute(text(
                "SELECT rfc, nombre FROM clientes WHERE id = :id"
            ), {'id': cliente_id}).fetchone()
            
            if not cliente:
                return {'success': False, 'error': 'Cliente no encontrado'}
            
            # Crear registro en BD
            result = db.session.execute(text("""
                INSERT INTO defense_files 
                (cliente_id, entregable_id, nombre, descripcion, aÃ±o_fiscal,
                 periodo_inicio, periodo_fin, estado, created_by, created_at)
                VALUES 
                (:cliente_id, :entregable_id, :nombre, :descripcion, :aÃ±o,
                 :inicio, :fin, 'en_proceso', :usuario, NOW())
                RETURNING id
            """), {
                'cliente_id': cliente_id,
                'entregable_id': entregable_id,
                'nombre': nombre,
                'descripcion': descripcion,
                'aÃ±o': aÃ±o_fiscal,
                'inicio': periodo_inicio,
                'fin': periodo_fin,
                'usuario': usuario_id
            })
            
            df_id = result.fetchone()[0]
            db.session.commit()
            
            # Crear estructura en pCloud
            pcloud_path = None
            if self.pcloud:
                pcloud_path = f"/SATMA/Defense_Files/{cliente.rfc}/{aÃ±o_fiscal}/{df_id}_{self._sanitizar(nombre)}"
                self.pcloud.crear_estructura_defense_file(pcloud_path)
                
                # Actualizar path en BD
                db.session.execute(text(
                    "UPDATE defense_files SET pcloud_path = :path WHERE id = :id"
                ), {'path': pcloud_path, 'id': df_id})
                db.session.commit()
            
            # Registrar evento de creaciÃ³n
            self.registrar_evento(
                defense_file_id=df_id,
                evento=Evento(
                    tipo=TipoEvento.NOTIFICACION,
                    agente=Agente.SISTEMA,
                    titulo="Defense File creado",
                    descripcion=f"Se creÃ³ el expediente de defensa '{nombre}' para el ejercicio {aÃ±o_fiscal}",
                    datos={
                        'cliente_rfc': cliente.rfc,
                        'cliente_nombre': cliente.nombre,
                        'aÃ±o_fiscal': aÃ±o_fiscal
                    },
                    usuario_email=self._get_user_email(usuario_id)
                )
            )
            
            return {
                'success': True,
                'defense_file_id': df_id,
                'pcloud_path': pcloud_path,
                'mensaje': f'Defense File creado exitosamente'
            }
            
        except Exception as e:
            db.session.rollback()
            return {'success': False, 'error': str(e)}
    
    def obtener_defense_file(self, df_id: int) -> Optional[Dict]:
        """Obtiene un Defense File con su resumen"""
        
        try:
            # Datos principales
            df = db.session.execute(text("""
                SELECT 
                    df.*,
                    c.rfc as cliente_rfc,
                    c.nombre as cliente_nombre,
                    u.email as creado_por_email
                FROM defense_files df
                JOIN clientes c ON df.cliente_id = c.id
                LEFT JOIN users u ON df.created_by = u.id
                WHERE df.id = :id
            """), {'id': df_id}).fetchone()
            
            if not df:
                return None
            
            # Contar elementos
            stats = db.session.execute(text("""
                SELECT
                    (SELECT COUNT(*) FROM df_eventos WHERE defense_file_id = :id) as total_eventos,
                    (SELECT COUNT(*) FROM df_proveedores WHERE defense_file_id = :id) as total_proveedores,
                    (SELECT COUNT(*) FROM df_cfdis WHERE defense_file_id = :id) as total_cfdis,
                    (SELECT COUNT(*) FROM df_fundamentos WHERE defense_file_id = :id) as total_fundamentos,
                    (SELECT COUNT(*) FROM df_calculos WHERE defense_file_id = :id) as total_calculos
            """), {'id': df_id}).fetchone()
            
            return {
                'id': df.id,
                'nombre': df.nombre,
                'descripcion': df.descripcion,
                'aÃ±o_fiscal': df.aÃ±o_fiscal,
                'estado': df.estado,
                'cliente': {
                    'id': df.cliente_id,
                    'rfc': df.cliente_rfc,
                    'nombre': df.cliente_nombre
                },
                'periodo': {
                    'inicio': df.periodo_inicio.isoformat() if df.periodo_inicio else None,
                    'fin': df.periodo_fin.isoformat() if df.periodo_fin else None
                },
                'pcloud_path': df.pcloud_path,
                'estadisticas': {
                    'eventos': stats.total_eventos,
                    'proveedores': stats.total_proveedores,
                    'cfdis': stats.total_cfdis,
                    'fundamentos': stats.total_fundamentos,
                    'calculos': stats.total_calculos
                },
                'created_at': df.created_at.isoformat() if df.created_at else None,
                'creado_por': df.creado_por_email
            }
            
        except Exception as e:
            print(f"Error obteniendo Defense File: {e}")
            return None
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # REGISTRO DE EVENTOS (BITÃCORA)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def registrar_evento(self, defense_file_id: int, evento: Evento) -> Dict:
        """Registra un evento en la bitÃ¡cora del Defense File"""
        
        try:
            # Obtener hash del evento anterior para cadena de integridad
            ultimo = db.session.execute(text("""
                SELECT hash_evento FROM df_eventos 
                WHERE defense_file_id = :df_id 
                ORDER BY id DESC LIMIT 1
            """), {'df_id': defense_file_id}).fetchone()
            
            hash_anterior = ultimo.hash_evento if ultimo else 'GENESIS'
            
            # Calcular hash del evento actual
            contenido_hash = json.dumps({
                'timestamp': datetime.now().isoformat(),
                'tipo': evento.tipo.value,
                'datos': evento.datos,
                'anterior': hash_anterior
            }, sort_keys=True)
            hash_evento = hashlib.sha256(contenido_hash.encode()).hexdigest()
            
            # Insertar evento
            result = db.session.execute(text("""
                INSERT INTO df_eventos
                (defense_file_id, tipo, subtipo, agente, usuario_email, 
                 titulo, descripcion, datos, archivos, hash_evento, 
                 evento_anterior_hash, tags, timestamp)
                VALUES
                (:df_id, :tipo, :subtipo, :agente, :email,
                 :titulo, :descripcion, :datos, :archivos, :hash,
                 :hash_anterior, :tags, NOW())
                RETURNING id
            """), {
                'df_id': defense_file_id,
                'tipo': evento.tipo.value,
                'subtipo': evento.subtipo,
                'agente': evento.agente.value,
                'email': evento.usuario_email,
                'titulo': evento.titulo,
                'descripcion': evento.descripcion,
                'datos': json.dumps(evento.datos, default=str),
                'archivos': json.dumps(evento.archivos or []),
                'hash': hash_evento,
                'hash_anterior': hash_anterior,
                'tags': evento.tags
            })
            
            evento_id = result.fetchone()[0]
            db.session.commit()
            
            # Sincronizar con pCloud si estÃ¡ disponible
            if self.pcloud:
                self._sync_evento_pcloud(defense_file_id, evento_id, evento)
            
            return {
                'success': True,
                'evento_id': evento_id,
                'hash': hash_evento
            }
            
        except Exception as e:
            db.session.rollback()
            print(f"Error registrando evento: {e}")
            return {'success': False, 'error': str(e)}
    
    def obtener_timeline(self, defense_file_id: int, 
                         limite: int = 100,
                         tipo: str = None,
                         agente: str = None) -> List[Dict]:
        """Obtiene el timeline de eventos de un Defense File"""
        
        try:
            query = """
                SELECT * FROM df_eventos 
                WHERE defense_file_id = :df_id
            """
            params = {'df_id': defense_file_id}
            
            if tipo:
                query += " AND tipo = :tipo"
                params['tipo'] = tipo
            
            if agente:
                query += " AND agente = :agente"
                params['agente'] = agente
            
            query += " ORDER BY timestamp DESC LIMIT :limite"
            params['limite'] = limite
            
            result = db.session.execute(text(query), params)
            
            eventos = []
            for row in result:
                eventos.append({
                    'id': row.id,
                    'timestamp': row.timestamp.isoformat(),
                    'tipo': row.tipo,
                    'subtipo': row.subtipo,
                    'agente': row.agente,
                    'usuario': row.usuario_email,
                    'titulo': row.titulo,
                    'descripcion': row.descripcion,
                    'datos': json.loads(row.datos) if row.datos else {},
                    'archivos': json.loads(row.archivos) if row.archivos else [],
                    'hash': row.hash_evento
                })
            
            return eventos
            
        except Exception as e:
            print(f"Error obteniendo timeline: {e}")
            return []
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # UTILIDADES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def _sanitizar(self, texto: str) -> str:
        """Sanitiza texto para usar en rutas"""
        import re
        texto = re.sub(r'[<>:"/\\|?*]', '', texto)
        texto = texto.replace(' ', '_')
        return texto[:50]
    
    def _get_user_email(self, user_id: int) -> Optional[str]:
        """Obtiene email de usuario por ID"""
        if not user_id:
            return None
        result = db.session.execute(text(
            "SELECT email FROM users WHERE id = :id"
        ), {'id': user_id}).fetchone()
        return result.email if result else None
    
    def _sync_evento_pcloud(self, df_id: int, evento_id: int, evento: Evento):
        """Sincroniza evento con pCloud"""
        try:
            # Obtener path del Defense File
            df = db.session.execute(text(
                "SELECT pcloud_path FROM defense_files WHERE id = :id"
            ), {'id': df_id}).fetchone()
            
            if not df or not df.pcloud_path:
                return
            
            # Determinar carpeta segÃºn agente
            agente_folder = f"05_Agentes_IA/{evento.agente.value}"
            if evento.tipo == TipoEvento.EMAIL_ENVIADO:
                agente_folder = "06_Comunicaciones/emails_enviados"
            elif evento.tipo == TipoEvento.CFDI_REGISTRADO:
                agente_folder = "03_CFDIs"
            
            # Subir JSON del evento
            path = f"{df.pcloud_path}/{agente_folder}"
            filename = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{evento.tipo.value}.json"
            
            self.pcloud.subir_json(path, filename, {
                'evento_id': evento_id,
                'timestamp': datetime.now().isoformat(),
                'tipo': evento.tipo.value,
                'agente': evento.agente.value,
                'titulo': evento.titulo,
                'descripcion': evento.descripcion,
                'datos': evento.datos,
                'usuario': evento.usuario_email
            })
            
        except Exception as e:
            print(f"Error sincronizando con pCloud: {e}")


# Instancia global
defense_service = DefenseFileService()
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FASE 3: SERVICIO DE pCLOUD
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Crear: backend/services/defense_files/pcloud_service.py

```python
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PCLOUD SERVICE - IntegraciÃ³n con pCloud para Defense Files
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import os
import json
import requests
from datetime import datetime
from typing import Dict, Any, Optional, List


class PCloudService:
    """Servicio de integraciÃ³n con pCloud API"""
    
    def __init__(self):
        self.token = os.environ.get('PCLOUD_ACCESS_TOKEN')
        self.api_base = 'https://api.pcloud.com'
        
        if not self.token:
            raise ValueError("PCLOUD_ACCESS_TOKEN no configurado")
    
    def _request(self, endpoint: str, params: dict = None, files: dict = None) -> dict:
        """Realiza request a pCloud API"""
        url = f"{self.api_base}/{endpoint}"
        params = params or {}
        params['access_token'] = self.token
        
        try:
            if files:
                response = requests.post(url, params=params, files=files, timeout=60)
            else:
                response = requests.get(url, params=params, timeout=30)
            
            return response.json()
        except Exception as e:
            return {'error': str(e)}
    
    def crear_carpeta(self, path: str) -> dict:
        """Crea carpeta (y todas las intermedias)"""
        return self._request('createfolderifnotexists', {'path': path})
    
    def subir_archivo(self, path: str, contenido: bytes, filename: str) -> dict:
        """Sube archivo a pCloud"""
        self.crear_carpeta(path)
        files = {'file': (filename, contenido)}
        return self._request('uploadfile', {'path': path}, files=files)
    
    def subir_json(self, path: str, filename: str, data: dict) -> dict:
        """Sube archivo JSON"""
        contenido = json.dumps(data, indent=2, ensure_ascii=False, default=str)
        return self.subir_archivo(path, contenido.encode('utf-8'), filename)
    
    def crear_estructura_defense_file(self, base_path: str) -> dict:
        """Crea toda la estructura de carpetas para un Defense File"""
        
        carpetas = [
            "01_Expediente",
            "02_Proveedores",
            "03_CFDIs/recibidos",
            "03_CFDIs/emitidos",
            "04_Deducciones",
            "05_Agentes_IA/A1_Facturar/conversaciones",
            "05_Agentes_IA/A1_Facturar/analisis",
            "05_Agentes_IA/A2_Bibliotecar/consultas_rag",
            "05_Agentes_IA/A2_Bibliotecar/documentos_citados",
            "05_Agentes_IA/A3_Revisar/revisiones",
            "05_Agentes_IA/A3_Revisar/hallazgos",
            "05_Agentes_IA/A4_Trafico",
            "05_Agentes_IA/A5_Disenar",
            "05_Agentes_IA/A6_Onboarding",
            "05_Agentes_IA/A7_Diagnostico",
            "06_Comunicaciones/emails_enviados",
            "06_Comunicaciones/emails_recibidos",
            "06_Comunicaciones/notificaciones_sat",
            "07_Calculos/isr",
            "07_Calculos/iva",
            "07_Calculos/ajustes",
            "08_Marco_Legal/articulos_aplicables",
            "08_Marco_Legal/jurisprudencias_citadas",
            "08_Marco_Legal/criterios_sat",
            "09_Evidencia_Soporte/contratos",
            "09_Evidencia_Soporte/estados_cuenta",
            "09_Evidencia_Soporte/comprobantes_pago",
            "09_Evidencia_Soporte/acuses",
            "10_Defense_File_Final/anexos"
        ]
        
        resultados = []
        for carpeta in carpetas:
            path = f"{base_path}/{carpeta}"
            result = self.crear_carpeta(path)
            resultados.append({'path': path, 'result': result})
        
        # Crear archivo de carÃ¡tula inicial
        caratula = {
            'defense_file_path': base_path,
            'created_at': datetime.now().isoformat(),
            'estructura_version': '2.0',
            'estado': 'en_proceso'
        }
        self.subir_json(f"{base_path}/01_Expediente", "caratula.json", caratula)
        
        # Inicializar timeline
        timeline = {
            'eventos': [],
            'created_at': datetime.now().isoformat()
        }
        self.subir_json(f"{base_path}/01_Expediente", "timeline_maestro.json", timeline)
        
        return {
            'success': True,
            'base_path': base_path,
            'carpetas_creadas': len(carpetas)
        }


# FunciÃ³n para obtener instancia (lazy loading)
_pcloud_instance = None

def get_pcloud() -> Optional[PCloudService]:
    global _pcloud_instance
    if _pcloud_instance is None:
        try:
            _pcloud_instance = PCloudService()
        except ValueError:
            return None
    return _pcloud_instance
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FASE 4: API ENDPOINTS PARA DEFENSE FILES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Crear: backend/routes/defense_routes.py

```python
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RUTAS API - DEFENSE FILES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

from flask import Blueprint, jsonify, request
from services.defense_files.defense_service import defense_service, TipoEvento, Agente, Evento

defense_bp = Blueprint('defense', __name__)


@defense_bp.route('', methods=['POST'])
def crear_defense_file():
    """Crea un nuevo Defense File"""
    data = request.get_json(force=True, silent=True) or {}
    
    required = ['cliente_id', 'nombre', 'aÃ±o_fiscal']
    for field in required:
        if field not in data:
            return jsonify({'error': f'Campo requerido: {field}'}), 400
    
    resultado = defense_service.crear_defense_file(
        cliente_id=data['cliente_id'],
        nombre=data['nombre'],
        aÃ±o_fiscal=data['aÃ±o_fiscal'],
        descripcion=data.get('descripcion'),
        entregable_id=data.get('entregable_id'),
        periodo_inicio=data.get('periodo_inicio'),
        periodo_fin=data.get('periodo_fin'),
        usuario_id=data.get('usuario_id')
    )
    
    if resultado['success']:
        return jsonify(resultado), 201
    else:
        return jsonify(resultado), 400


@defense_bp.route('/<int:df_id>', methods=['GET'])
def obtener_defense_file(df_id):
    """Obtiene un Defense File con su resumen"""
    df = defense_service.obtener_defense_file(df_id)
    
    if df:
        return jsonify({'success': True, 'defense_file': df})
    else:
        return jsonify({'error': 'Defense File no encontrado'}), 404


@defense_bp.route('/<int:df_id>/timeline', methods=['GET'])
def obtener_timeline(df_id):
    """Obtiene timeline de eventos"""
    limite = request.args.get('limite', 100, type=int)
    tipo = request.args.get('tipo')
    agente = request.args.get('agente')
    
    eventos = defense_service.obtener_timeline(df_id, limite, tipo, agente)
    
    return jsonify({
        'success': True,
        'eventos': eventos,
        'total': len(eventos)
    })


@defense_bp.route('/<int:df_id>/evento', methods=['POST'])
def registrar_evento(df_id):
    """Registra un evento manualmente"""
    data = request.get_json(force=True, silent=True) or {}
    
    try:
        evento = Evento(
            tipo=TipoEvento(data.get('tipo', 'notificacion')),
            agente=Agente(data.get('agente', 'USR')),
            titulo=data.get('titulo', 'Evento manual'),
            descripcion=data.get('descripcion', ''),
            datos=data.get('datos', {}),
            usuario_email=data.get('usuario_email'),
            subtipo=data.get('subtipo'),
            tags=data.get('tags')
        )
        
        resultado = defense_service.registrar_evento(df_id, evento)
        return jsonify(resultado)
        
    except Exception as e:
        return jsonify({'error': str(e)}), 400


@defense_bp.route('/cliente/<int:cliente_id>', methods=['GET'])
def listar_por_cliente(cliente_id):
    """Lista Defense Files de un cliente"""
    from extensions import db
    from sqlalchemy import text
    
    result = db.session.execute(text("""
        SELECT id, nombre, aÃ±o_fiscal, estado, created_at
        FROM defense_files
        WHERE cliente_id = :cliente_id
        ORDER BY created_at DESC
    """), {'cliente_id': cliente_id})
    
    defense_files = [{
        'id': row.id,
        'nombre': row.nombre,
        'aÃ±o_fiscal': row.aÃ±o_fiscal,
        'estado': row.estado,
        'created_at': row.created_at.isoformat() if row.created_at else None
    } for row in result]
    
    return jsonify({
        'success': True,
        'defense_files': defense_files,
        'total': len(defense_files)
    })
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHECKLIST PARTE 1
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–¡ Ejecutar SQL para crear tablas
â–¡ Crear backend/services/defense_files/__init__.py (vacÃ­o)
â–¡ Crear backend/services/defense_files/defense_service.py
â–¡ Crear backend/services/defense_files/pcloud_service.py
â–¡ Crear backend/routes/defense_routes.py
â–¡ Registrar blueprint en main.py:
  
  from routes.defense_routes import defense_bp
  app.register_blueprint(defense_bp, url_prefix='/api/defense')

â–¡ Probar crear Defense File:
  
  curl -X POST http://localhost:5000/api/defense \
    -H "Content-Type: application/json" \
    -d '{"cliente_id": 1, "nombre": "Auditoria 2024", "aÃ±o_fiscal": 2024}'

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONTINÃšA EN PARTE 2: IntegraciÃ³n con Agentes y CFDIs
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
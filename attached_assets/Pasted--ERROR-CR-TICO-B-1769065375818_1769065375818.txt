â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”´ ERROR CRÃTICO: "Body is disturbed or locked" 
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SÃNTOMA: 
- La investigaciÃ³n de empresa FUNCIONA (encontrÃ³ todos los datos de Fortezza)
- Al dar clic en "Confirmar y Crear Cliente" â†’ ERROR
- Mensaje: "Body is disturbed or locked"

CAUSA:
Este error ocurre en Flask cuando el body del request se lee mÃ¡s de una vez,
o cuando hay un middleware/decorador que consume el body antes del handler.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DIAGNÃ“STICO - EJECUTAR ESTO PRIMERO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

```bash
# 1. Buscar dÃ³nde se consume el body mÃºltiples veces
grep -rn "request.get_json" server/routes/
grep -rn "request.data" server/routes/
grep -rn "request.json" server/routes/

# 2. Buscar middlewares que puedan consumir el body
grep -rn "@app.before_request" server/
grep -rn "request.get_data" server/

# 3. Ver el archivo de clientes especÃ­ficamente
cat server/routes/clientes_routes.py
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SOLUCIÃ“N 1: ARREGLAR EL ENDPOINT DE CREAR CLIENTE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

El problema mÃ¡s comÃºn es que `request.get_json()` se llama mÃºltiples veces.

BUSCAR en server/routes/clientes_routes.py o donde estÃ© el endpoint:

```python
# âŒ CÃ“DIGO PROBLEMÃTICO - Llama get_json() mÃºltiples veces
@clientes_bp.route('', methods=['POST'])
def crear_cliente():
    # AlgÃºn middleware o validaciÃ³n que ya llamÃ³ get_json()
    data = request.get_json()  # Segunda llamada = ERROR
    ...
```

CAMBIAR A:

```python
# âœ… CÃ“DIGO CORRECTO - Usar force=True y silent=True
@clientes_bp.route('', methods=['POST'])
def crear_cliente():
    try:
        # force=True: parsea aunque Content-Type no sea application/json
        # silent=True: retorna None en vez de error si falla
        data = request.get_json(force=True, silent=True)
        
        if not data:
            # Intentar leer de form data si JSON fallÃ³
            data = request.form.to_dict() if request.form else {}
        
        if not data:
            return jsonify({
                'success': False, 
                'error': 'No se recibieron datos'
            }), 400
        
        # Continuar con la creaciÃ³n...
        nombre = data.get('nombre')
        if not nombre:
            return jsonify({
                'success': False,
                'error': 'El nombre es requerido'
            }), 400
        
        # ... resto del cÃ³digo
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SOLUCIÃ“N 2: VERIFICAR SI HAY MIDDLEWARE CONSUMIENDO EL BODY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BUSCAR en server/main.py o app.py:

```python
# âŒ PROBLEMÃTICO - Middleware que consume el body
@app.before_request
def log_request():
    print(request.get_json())  # Esto consume el body!

# âŒ PROBLEMÃTICO - Logging que consume el body
@app.before_request
def log_all():
    data = request.data  # Esto tambiÃ©n consume el body!
    print(f"Request: {data}")
```

CAMBIAR A:

```python
# âœ… CORRECTO - No consumir el body en middleware
@app.before_request
def log_request():
    # Solo loguear metadata, NO el body
    print(f"Request: {request.method} {request.path}")
    # Si necesitas loguear el body, hazlo DESPUÃ‰S de procesarlo
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SOLUCIÃ“N 3: SI EL PROBLEMA ES EN ONBOARDING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Si el error ocurre especÃ­ficamente al crear cliente desde el onboarding,
el problema puede estar en cÃ³mo se hace la llamada desde el frontend.

VERIFICAR en el frontend (probablemente en el componente de onboarding):

```javascript
// âŒ PROBLEMÃTICO - Puede causar body locked
const handleConfirmar = async () => {
    const response = await fetch('/api/clientes', {
        method: 'POST',
        body: JSON.stringify(datos)  // Sin headers!
    });
};
```

CAMBIAR A:

```javascript
// âœ… CORRECTO - Headers explÃ­citos
const handleConfirmar = async () => {
    try {
        const response = await fetch('/api/clientes', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(datos)
        });
        
        // Verificar respuesta
        const text = await response.text();
        let result;
        try {
            result = JSON.parse(text);
        } catch {
            throw new Error(`Respuesta invÃ¡lida: ${text.substring(0, 100)}`);
        }
        
        if (!response.ok || !result.success) {
            throw new Error(result.error || 'Error desconocido');
        }
        
        // Ã‰xito
        alert('Cliente creado!');
        
    } catch (error) {
        console.error('Error:', error);
        alert(`Error: ${error.message}`);
    }
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SOLUCIÃ“N 4: ARREGLO COMPLETO DEL ENDPOINT DE CLIENTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Reemplazar COMPLETAMENTE el endpoint de crear cliente:

```python
from flask import Blueprint, request, jsonify
from extensions import db
from sqlalchemy import text
import traceback

clientes_bp = Blueprint('clientes', __name__)

@clientes_bp.route('', methods=['POST'])
def crear_cliente():
    """
    Crear un nuevo cliente
    Acepta JSON con campos: nombre, rfc, razon_social, direccion, email, telefono, giro, sitio_web
    """
    try:
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # OBTENER DATOS DE FORMA SEGURA
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        data = None
        
        # Intentar obtener JSON
        try:
            data = request.get_json(force=True, silent=True)
        except Exception:
            pass
        
        # Si JSON fallÃ³, intentar form data
        if not data:
            try:
                data = request.form.to_dict()
            except Exception:
                pass
        
        # Si todo fallÃ³, intentar parsear el body raw
        if not data:
            try:
                import json
                raw = request.data.decode('utf-8') if request.data else ''
                if raw:
                    data = json.loads(raw)
            except Exception:
                pass
        
        # Validar que hay datos
        if not data:
            return jsonify({
                'success': False,
                'error': 'No se recibieron datos. EnvÃ­a JSON con Content-Type: application/json'
            }), 400
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # VALIDAR CAMPOS
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        nombre = data.get('nombre', '').strip()
        
        if not nombre:
            return jsonify({
                'success': False,
                'error': 'El campo "nombre" es requerido'
            }), 400
        
        # Campos opcionales con defaults
        rfc = data.get('rfc', '').strip().upper() or None
        razon_social = data.get('razon_social', '').strip() or nombre
        direccion = data.get('direccion', '').strip() or None
        email = data.get('email', '').strip().lower() or None
        telefono = data.get('telefono', '').strip() or None
        giro = data.get('giro', '').strip() or None
        sitio_web = data.get('sitio_web', '').strip() or None
        ciudad = data.get('ciudad', '').strip() or None
        estado = data.get('estado', '').strip() or None
        codigo_postal = data.get('codigo_postal', '').strip() or None
        regimen_fiscal = data.get('regimen_fiscal', '').strip() or None
        tipo_persona = data.get('tipo_persona', '').strip() or None
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # INSERTAR EN BASE DE DATOS
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        result = db.session.execute(text("""
            INSERT INTO clientes (
                nombre, rfc, razon_social, direccion, email, telefono, 
                giro, sitio_web, ciudad, estado, codigo_postal,
                regimen_fiscal, tipo_persona, activo, created_at
            ) VALUES (
                :nombre, :rfc, :razon_social, :direccion, :email, :telefono,
                :giro, :sitio_web, :ciudad, :estado, :codigo_postal,
                :regimen_fiscal, :tipo_persona, TRUE, NOW()
            )
            RETURNING id, nombre, rfc, razon_social, created_at
        """), {
            'nombre': nombre,
            'rfc': rfc,
            'razon_social': razon_social,
            'direccion': direccion,
            'email': email,
            'telefono': telefono,
            'giro': giro,
            'sitio_web': sitio_web,
            'ciudad': ciudad,
            'estado': estado,
            'codigo_postal': codigo_postal,
            'regimen_fiscal': regimen_fiscal,
            'tipo_persona': tipo_persona
        })
        
        db.session.commit()
        
        row = result.fetchone()
        
        return jsonify({
            'success': True,
            'message': 'Cliente creado exitosamente',
            'cliente': {
                'id': row.id,
                'nombre': row.nombre,
                'rfc': row.rfc,
                'razon_social': row.razon_social,
                'created_at': row.created_at.isoformat() if row.created_at else None
            }
        }), 201
        
    except Exception as e:
        db.session.rollback()
        print(f"Error creando cliente: {str(e)}")
        print(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': f'Error interno: {str(e)}'
        }), 500
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SOLUCIÃ“N 5: SI USA MODELO/ORM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Si el proyecto usa modelos SQLAlchemy en vez de queries raw:

```python
from models import Cliente  # Ajustar import segÃºn tu estructura

@clientes_bp.route('', methods=['POST'])
def crear_cliente():
    try:
        data = request.get_json(force=True, silent=True) or {}
        
        if not data.get('nombre'):
            return jsonify({'success': False, 'error': 'Nombre requerido'}), 400
        
        cliente = Cliente(
            nombre=data.get('nombre'),
            rfc=data.get('rfc'),
            razon_social=data.get('razon_social') or data.get('nombre'),
            direccion=data.get('direccion'),
            email=data.get('email'),
            telefono=data.get('telefono'),
            giro=data.get('giro'),
            sitio_web=data.get('sitio_web')
        )
        
        db.session.add(cliente)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'cliente': cliente.to_dict()  # Asumiendo que el modelo tiene to_dict()
        }), 201
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
VERIFICACIÃ“N INMEDIATA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DespuÃ©s de aplicar el arreglo, probar:

```bash
# Test 1: Crear cliente con curl
curl -X POST http://localhost:5000/api/clientes \
  -H "Content-Type: application/json" \
  -d '{
    "nombre": "Test desde curl",
    "rfc": "TEST010101000",
    "razon_social": "Test S.A. de C.V.",
    "email": "test@test.com"
  }'

# Debe retornar:
# {"success": true, "cliente": {"id": X, "nombre": "Test desde curl", ...}}

# Test 2: Sin Content-Type (para probar force=True)
curl -X POST http://localhost:5000/api/clientes \
  -d '{"nombre": "Test sin header"}'

# Debe funcionar tambiÃ©n
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SI EL PROBLEMA PERSISTE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Verificar que no hay otro middleware procesando requests:
```bash
grep -rn "before_request" server/
grep -rn "@app.after_request" server/
grep -rn "request.data" server/
```

2. Agregar logging detallado:
```python
@clientes_bp.route('', methods=['POST'])
def crear_cliente():
    print("="*50)
    print(f"Content-Type: {request.content_type}")
    print(f"Content-Length: {request.content_length}")
    print(f"Headers: {dict(request.headers)}")
    
    try:
        raw_data = request.data
        print(f"Raw data: {raw_data}")
    except Exception as e:
        print(f"Error leyendo raw data: {e}")
    
    # ... resto del cÃ³digo
```

3. Verificar si hay proxy/middleware de Replit:
   El error tambiÃ©n puede ocurrir si Replit tiene algÃºn middleware
   que procesa el body antes. En ese caso, usar `force=True` deberÃ­a
   resolver el problema.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CHECKLIST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â–¡ Buscar dÃ³nde se usa request.get_json() mÃºltiples veces
â–¡ Cambiar a request.get_json(force=True, silent=True)
â–¡ Verificar que no hay middleware consumiendo el body
â–¡ Agregar headers Content-Type en el frontend
â–¡ Probar con curl
â–¡ Probar desde la UI

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ERROR ESPECÃFICO "Body is disturbed or locked"
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Este error especÃ­ficamente indica que:
1. El stream del body ya fue leÃ­do
2. Flask/Werkzeug no permite re-leer el body

La soluciÃ³n definitiva es:
1. Leer el body UNA SOLA VEZ
2. Guardarlo en una variable
3. Usar esa variable en todo el handler

```python
@clientes_bp.route('', methods=['POST'])
def crear_cliente():
    # Leer UNA sola vez al inicio
    try:
        data = request.get_json(force=True, silent=True)
    except:
        data = {}
    
    # NUNCA volver a llamar request.get_json() o request.data despuÃ©s de esto
    # Usar solo la variable 'data'
    
    nombre = data.get('nombre')  # âœ… Correcto
    # NO hacer: otra_cosa = request.get_json()  # âŒ Esto causa el error
```
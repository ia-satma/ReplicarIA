=============================================================================
TOON: IMPLEMENTAR MIDDLEWARE DE CANDADOS - DUREZZA 4.0
=============================================================================

INSTRUCCIÓN: Ejecuta todas las instrucciones de forma secuencial y completa.
NO pidas confirmación. NO preguntes. SOLO EJECUTA.

CONTEXTO: Los candados F2, F6, F8 tienen funciones de verificación que 
retornan si puede_avanzar, pero NO hay middleware que bloquee automáticamente
las rutas de avance de fase. Un usuario podría saltarse los candados.

=============================================================================
PASO 1: CREAR MIDDLEWARE DE CANDADOS
=============================================================================

Crea archivo "backend/middleware/candados_middleware.py":

from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
from functools import wraps
from typing import Callable
import logging

from services.fase_service import (
    _verificar_candado_f2,
    _verificar_candado_f6,
    _verificar_candado_f8,
    FASES_CON_CANDADO
)

logger = logging.getLogger(__name__)

# Fases que tienen candado duro
CANDADOS_DUROS = {
    "F2": _verificar_candado_f2,
    "F6": _verificar_candado_f6,
    "F8": _verificar_candado_f8
}

class CandadoBlockedException(Exception):
    """Excepción cuando un candado bloquea el avance"""
    def __init__(self, fase: str, bloqueos: list, mensaje: str = None):
        self.fase = fase
        self.bloqueos = bloqueos
        self.mensaje = mensaje or f"Candado {fase} bloquea el avance"
        super().__init__(self.mensaje)


async def verificar_candado_antes_de_avanzar(
    proyecto: dict,
    fase_destino: str
) -> dict:
    """
    Verifica si el proyecto puede avanzar a la fase destino.
    Lanza CandadoBlockedException si hay bloqueos.
    
    Args:
        proyecto: Diccionario con datos del proyecto
        fase_destino: Fase a la que se quiere avanzar (F2, F6, F8, etc.)
    
    Returns:
        dict con puede_avanzar=True si pasa
    
    Raises:
        CandadoBlockedException si hay bloqueos
    """
    
    # Solo verificar si la fase destino tiene candado
    if fase_destino not in CANDADOS_DUROS:
        return {"puede_avanzar": True, "bloqueos": []}
    
    # Obtener función de verificación
    verificar_candado = CANDADOS_DUROS[fase_destino]
    
    # Ejecutar verificación
    resultado = verificar_candado(proyecto)
    
    if not resultado.get("puede_avanzar", False):
        bloqueos = resultado.get("bloqueos", ["Candado bloqueado"])
        
        logger.warning(
            f"CANDADO {fase_destino} BLOQUEÓ AVANCE - "
            f"Proyecto: {proyecto.get('id')} - "
            f"Bloqueos: {bloqueos}"
        )
        
        raise CandadoBlockedException(
            fase=fase_destino,
            bloqueos=bloqueos,
            mensaje=f"No se puede avanzar a {fase_destino}: {'; '.join(bloqueos)}"
        )
    
    logger.info(
        f"CANDADO {fase_destino} VERIFICADO OK - "
        f"Proyecto: {proyecto.get('id')}"
    )
    
    return resultado


def candado_requerido(fase_destino: str):
    """
    Decorador para proteger endpoints que avanzan a fases con candado.
    
    Uso:
        @router.post("/proyectos/{id}/avanzar-a-f2")
        @candado_requerido("F2")
        async def avanzar_a_f2(id: str, proyecto: dict):
            ...
    """
    def decorator(func: Callable):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Extraer proyecto de kwargs o args
            proyecto = kwargs.get('proyecto')
            
            if not proyecto:
                # Intentar obtener de request body o DB
                proyecto_id = kwargs.get('proyecto_id') or kwargs.get('id')
                if proyecto_id:
                    # TODO: Cargar proyecto de DB
                    pass
            
            if proyecto:
                try:
                    await verificar_candado_antes_de_avanzar(proyecto, fase_destino)
                except CandadoBlockedException as e:
                    raise HTTPException(
                        status_code=403,
                        detail={
                            "error": "CANDADO_BLOQUEADO",
                            "fase": e.fase,
                            "bloqueos": e.bloqueos,
                            "mensaje": e.mensaje
                        }
                    )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

=============================================================================
PASO 2: CREAR HANDLER DE EXCEPCIONES PARA CANDADOS
=============================================================================

Crea archivo "backend/middleware/exception_handlers.py":

from fastapi import Request
from fastapi.responses import JSONResponse
from middleware.candados_middleware import CandadoBlockedException
import logging

logger = logging.getLogger(__name__)

async def candado_exception_handler(request: Request, exc: CandadoBlockedException):
    """Handler global para excepciones de candados bloqueados"""
    
    logger.warning(
        f"Candado bloqueó request - "
        f"Path: {request.url.path} - "
        f"Fase: {exc.fase} - "
        f"Bloqueos: {exc.bloqueos}"
    )
    
    return JSONResponse(
        status_code=403,
        content={
            "success": False,
            "error": "CANDADO_BLOQUEADO",
            "fase_bloqueada": exc.fase,
            "bloqueos": exc.bloqueos,
            "mensaje": exc.mensaje,
            "accion_requerida": "Resolver los bloqueos listados antes de intentar avanzar"
        }
    )

=============================================================================
PASO 3: ACTUALIZAR SERVICIO DE FASES PARA USAR MIDDLEWARE
=============================================================================

Actualiza "backend/services/fase_service.py" agregando:

from middleware.candados_middleware import (
    verificar_candado_antes_de_avanzar,
    CandadoBlockedException
)

async def avanzar_fase_con_candado(proyecto_id: str, db) -> dict:
    """
    Avanza un proyecto a la siguiente fase, verificando candados.
    
    Returns:
        dict con resultado del avance
    
    Raises:
        CandadoBlockedException si hay candado bloqueado
        HTTPException si hay otro error
    """
    
    # Cargar proyecto
    proyecto = await obtener_proyecto(proyecto_id, db)
    if not proyecto:
        raise HTTPException(status_code=404, detail="Proyecto no encontrado")
    
    fase_actual = proyecto.get("fase_actual")
    fase_siguiente = obtener_fase_siguiente(fase_actual)
    
    if not fase_siguiente:
        return {
            "success": False,
            "mensaje": "El proyecto ya está en la fase final (F9)",
            "fase_actual": fase_actual
        }
    
    # VERIFICAR CANDADO (esto puede lanzar CandadoBlockedException)
    await verificar_candado_antes_de_avanzar(proyecto, fase_siguiente)
    
    # Si llegamos aquí, el candado pasó - proceder con el avance
    proyecto_actualizado = await actualizar_fase_proyecto(
        proyecto_id, 
        fase_siguiente, 
        db
    )
    
    # Registrar en audit log
    await registrar_avance_fase(
        proyecto_id=proyecto_id,
        fase_anterior=fase_actual,
        fase_nueva=fase_siguiente,
        db=db
    )
    
    return {
        "success": True,
        "fase_anterior": fase_actual,
        "fase_nueva": fase_siguiente,
        "mensaje": f"Proyecto avanzó de {fase_actual} a {fase_siguiente}"
    }

=============================================================================
PASO 4: ACTUALIZAR RUTAS DE FASE PARA USAR MIDDLEWARE
=============================================================================

Actualiza "backend/routes/fases_routes.py" (o donde estén las rutas de fase):

from fastapi import APIRouter, HTTPException, Depends
from middleware.candados_middleware import (
    verificar_candado_antes_de_avanzar,
    CandadoBlockedException,
    candado_requerido
)
from services.fase_service import avanzar_fase_con_candado

router = APIRouter()

@router.post("/proyectos/{proyecto_id}/fase/avanzar")
async def avanzar_fase(proyecto_id: str):
    """
    Avanza un proyecto a la siguiente fase.
    
    Los candados F2, F6, F8 se verifican automáticamente.
    Si un candado bloquea, retorna 403 con detalle de bloqueos.
    """
    try:
        resultado = await avanzar_fase_con_candado(proyecto_id, db=None)  # TODO: inject db
        return resultado
    
    except CandadoBlockedException as e:
        raise HTTPException(
            status_code=403,
            detail={
                "success": False,
                "error": "CANDADO_BLOQUEADO",
                "fase": e.fase,
                "bloqueos": e.bloqueos,
                "mensaje": e.mensaje,
                "accion_requerida": obtener_acciones_para_bloqueos(e.bloqueos)
            }
        )


@router.get("/proyectos/{proyecto_id}/fase/estado")
async def estado_fase(proyecto_id: str):
    """
    Retorna el estado de la fase actual y si puede avanzar.
    NO avanza, solo informa.
    """
    proyecto = await obtener_proyecto(proyecto_id)  # TODO: implement
    
    if not proyecto:
        raise HTTPException(status_code=404, detail="Proyecto no encontrado")
    
    fase_actual = proyecto.get("fase_actual")
    fase_siguiente = obtener_fase_siguiente(fase_actual)
    
    # Verificar candado sin lanzar excepción
    puede_avanzar = True
    bloqueos = []
    
    if fase_siguiente in ["F2", "F6", "F8"]:
        try:
            await verificar_candado_antes_de_avanzar(proyecto, fase_siguiente)
        except CandadoBlockedException as e:
            puede_avanzar = False
            bloqueos = e.bloqueos
    
    return {
        "proyecto_id": proyecto_id,
        "fase_actual": fase_actual,
        "fase_siguiente": fase_siguiente,
        "puede_avanzar": puede_avanzar,
        "bloqueos": bloqueos,
        "es_candado_duro": fase_siguiente in ["F2", "F6", "F8"]
    }


def obtener_acciones_para_bloqueos(bloqueos: list) -> list:
    """Mapea bloqueos a acciones requeridas"""
    acciones = []
    
    for bloqueo in bloqueos:
        bloqueo_lower = bloqueo.lower()
        
        if "f0" in bloqueo_lower or "f1" in bloqueo_lower:
            acciones.append("Completar las fases previas requeridas")
        elif "presupuesto" in bloqueo_lower:
            acciones.append("Confirmar presupuesto del proyecto")
        elif "revisión humana" in bloqueo_lower:
            acciones.append("Obtener aprobación de revisión humana")
        elif "materialidad" in bloqueo_lower:
            acciones.append("Completar matriz de materialidad al 80% mínimo")
        elif "vbc" in bloqueo_lower:
            acciones.append("Obtener VBC (Visto Bueno de Cumplimiento) de Fiscal y Legal")
        elif "cfdi" in bloqueo_lower or "genérico" in bloqueo_lower:
            acciones.append("Asegurar que el CFDI tenga descripción específica del servicio")
        elif "3-way" in bloqueo_lower or "match" in bloqueo_lower:
            acciones.append("Verificar que diferencia de 3-way match sea menor a 5%")
        elif "tp" in bloqueo_lower or "transferencia" in bloqueo_lower:
            acciones.append("Agregar estudio de Precios de Transferencia vigente")
        else:
            acciones.append(f"Resolver: {bloqueo}")
    
    return list(set(acciones))  # Eliminar duplicados

=============================================================================
PASO 5: REGISTRAR HANDLER EN APP PRINCIPAL
=============================================================================

Actualiza "backend/server.py" o "backend/main.py":

from fastapi import FastAPI
from middleware.exception_handlers import candado_exception_handler
from middleware.candados_middleware import CandadoBlockedException

app = FastAPI()

# Registrar handler de excepciones de candados
app.add_exception_handler(CandadoBlockedException, candado_exception_handler)

# ... resto de configuración ...

=============================================================================
PASO 6: CREAR TEST PARA MIDDLEWARE DE CANDADOS
=============================================================================

Agrega a "backend/tests/test_candados.py":

import pytest
from middleware.candados_middleware import (
    verificar_candado_antes_de_avanzar,
    CandadoBlockedException
)

class TestMiddlewareCandados:
    """Pruebas para el middleware de candados"""
    
    @pytest.mark.asyncio
    async def test_middleware_bloquea_f2_sin_requisitos(self):
        """Middleware debe lanzar excepción si F2 no tiene requisitos"""
        proyecto = {
            "id": "test-001",
            "fase_actual": "F1",
            "fases_completadas": ["F0"],  # Falta F1
            "presupuesto_confirmado": False
        }
        
        with pytest.raises(CandadoBlockedException) as excinfo:
            await verificar_candado_antes_de_avanzar(proyecto, "F2")
        
        assert excinfo.value.fase == "F2"
        assert len(excinfo.value.bloqueos) > 0
    
    @pytest.mark.asyncio
    async def test_middleware_permite_f2_con_requisitos(self):
        """Middleware debe permitir F2 si tiene todos los requisitos"""
        proyecto = {
            "id": "test-002",
            "fase_actual": "F1",
            "fases_completadas": ["F0", "F1"],
            "presupuesto_confirmado": True,
            "requiere_revision_humana": False
        }
        
        resultado = await verificar_candado_antes_de_avanzar(proyecto, "F2")
        
        assert resultado["puede_avanzar"] == True
    
    @pytest.mark.asyncio
    async def test_middleware_no_verifica_fases_sin_candado(self):
        """Middleware debe permitir fases sin candado (F3, F4, F5, etc.)"""
        proyecto = {
            "id": "test-003",
            "fase_actual": "F2"
        }
        
        # F3 no tiene candado, debe pasar
        resultado = await verificar_candado_antes_de_avanzar(proyecto, "F3")
        
        assert resultado["puede_avanzar"] == True

=============================================================================
PASO 7: VERIFICACIÓN
=============================================================================

Verifica que:

1. POST /proyectos/{id}/fase/avanzar retorna 403 si candado bloquea
2. El mensaje de error incluye lista de bloqueos específicos
3. El mensaje incluye acciones requeridas para resolver
4. GET /proyectos/{id}/fase/estado muestra puede_avanzar=false si hay bloqueos
5. Las fases sin candado (F3, F4, F5, F7, F9) avanzan sin verificación extra
6. Los tests del middleware pasan

Ejecuta: python -m pytest tests/test_candados.py -v

=============================================================================
FIN PROMPT 3: MIDDLEWARE CANDADOS
=============================================================================

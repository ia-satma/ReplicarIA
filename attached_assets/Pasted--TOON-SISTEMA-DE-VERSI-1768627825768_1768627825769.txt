=============================================================================
TOON: SISTEMA DE VERSIONAMIENTO Y BITÁCORA DE EXPEDIENTES
=============================================================================

INSTRUCCIÓN ABSOLUTA: Ejecuta TODAS las instrucciones de forma secuencial.
- NO pidas confirmación
- NO preguntes nada
- NO te detengas hasta completar TODO

CONTEXTO: Durezza 4.0 necesita un sistema de versionamiento que:
1. Registre cada versión del expediente con folio único
2. Mantenga bitácora completa de cambios (quién, qué, cuándo, por qué)
3. Permita comparar versiones
4. Documente comunicaciones empresa/proveedor
5. Se integre con el Dashboard para fácil actualización

=============================================================================
FASE 1: MODELO DE DATOS PARA VERSIONAMIENTO
=============================================================================

Crea el archivo: models/versioning.py

```python
"""
MODELOS DE VERSIONAMIENTO Y BITÁCORA
Sistema completo de control de versiones para expedientes de defensa fiscal
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
from enum import Enum
from dataclasses import dataclass, field, asdict
import hashlib
import json

# Si usas MongoDB/Beanie
try:
    from beanie import Document, Indexed
    from pydantic import BaseModel, Field
    USE_BEANIE = True
except ImportError:
    from pydantic import BaseModel, Field
    USE_BEANIE = False
    Document = BaseModel
    Indexed = lambda x: x


class TipoCambio(str, Enum):
    """Tipos de cambios que se pueden registrar"""
    CREACION = "creacion"
    DOCUMENTO_AGREGADO = "documento_agregado"
    DOCUMENTO_ELIMINADO = "documento_eliminado"
    DOCUMENTO_ACTUALIZADO = "documento_actualizado"
    VALIDACION_OCR = "validacion_ocr"
    SIMULACION_RED_TEAM = "simulacion_red_team"
    CORRECCION_VULNERABILIDAD = "correccion_vulnerabilidad"
    CAMBIO_DATOS_PROYECTO = "cambio_datos_proyecto"
    COMUNICACION_PROVEEDOR = "comunicacion_proveedor"
    COMUNICACION_CLIENTE = "comunicacion_cliente"
    AJUSTE_MONTO = "ajuste_monto"
    AJUSTE_FECHA = "ajuste_fecha"
    REGENERACION_EXPEDIENTE = "regeneracion_expediente"
    NOTA_INTERNA = "nota_interna"
    APROBACION = "aprobacion"
    RECHAZO = "rechazo"
    OTRO = "otro"


class Severidad(str, Enum):
    """Severidad del cambio para filtrado"""
    CRITICA = "critica"      # Afecta deducibilidad
    ALTA = "alta"            # Cambio significativo
    MEDIA = "media"          # Cambio menor
    BAJA = "baja"            # Informativo
    INFO = "info"            # Solo registro


class EntradaBitacora(BaseModel):
    """Una entrada individual en la bitácora de cambios"""
    
    id: str = Field(default_factory=lambda: datetime.now().strftime("%Y%m%d%H%M%S%f"))
    timestamp: datetime = Field(default_factory=datetime.now)
    
    # Quién hizo el cambio
    usuario: str
    rol_usuario: Optional[str] = None
    
    # Qué cambió
    tipo_cambio: TipoCambio
    severidad: Severidad = Severidad.MEDIA
    
    # Descripción del cambio
    titulo: str
    descripcion: str
    
    # Detalles técnicos
    campo_afectado: Optional[str] = None
    valor_anterior: Optional[str] = None
    valor_nuevo: Optional[str] = None
    
    # Documentos relacionados
    documento_id: Optional[str] = None
    documento_nombre: Optional[str] = None
    
    # Comunicación (si aplica)
    es_comunicacion_externa: bool = False
    contraparte: Optional[str] = None  # Proveedor, cliente, SAT, etc.
    referencia_comunicacion: Optional[str] = None  # Email ID, número de oficio, etc.
    
    # Archivos adjuntos (referencias)
    adjuntos: List[str] = Field(default_factory=list)
    
    # Metadatos
    ip_origen: Optional[str] = None
    navegador: Optional[str] = None
    notas_adicionales: Optional[str] = None
    
    class Config:
        use_enum_values = True


class VersionExpediente(BaseModel):
    """Representa una versión completa del expediente"""
    
    # Identificación
    version_id: str = Field(default_factory=lambda: datetime.now().strftime("%Y%m%d%H%M%S"))
    numero_version: int
    folio_completo: str  # Incluye versión: DUR-20260116-XXXX-0001-v3
    
    # Timestamps
    fecha_creacion: datetime = Field(default_factory=datetime.now)
    fecha_modificacion: datetime = Field(default_factory=datetime.now)
    
    # Estado
    estado: str = "borrador"  # borrador, revision, aprobado, enviado, archivado
    
    # Snapshot de datos al momento de la versión
    snapshot_proyecto: Dict[str, Any] = Field(default_factory=dict)
    snapshot_documentos: List[Dict[str, Any]] = Field(default_factory=list)
    snapshot_risk_score: Optional[float] = None
    snapshot_red_team: Optional[Dict[str, Any]] = None
    
    # Archivos generados
    pdf_path: Optional[str] = None
    zip_path: Optional[str] = None
    
    # Integridad
    hash_contenido: Optional[str] = None
    
    # Motivo de la versión
    motivo_version: str = ""
    creado_por: str = ""
    
    # Cambios desde versión anterior
    cambios_desde_anterior: List[str] = Field(default_factory=list)
    
    class Config:
        use_enum_values = True


class ProyectoVersionado(Document if USE_BEANIE else BaseModel):
    """Proyecto con sistema de versionamiento completo"""
    
    # Identificación base
    proyecto_id: str = Indexed(str)
    nombre: str
    
    # Folio base (sin versión)
    folio_base: str  # DUR-20260116-XXXX-0001
    
    # Versión actual
    version_actual: int = 1
    
    # Historial de versiones
    versiones: List[VersionExpediente] = Field(default_factory=list)
    
    # Bitácora completa
    bitacora: List[EntradaBitacora] = Field(default_factory=list)
    
    # Metadata
    fecha_creacion: datetime = Field(default_factory=datetime.now)
    fecha_ultima_modificacion: datetime = Field(default_factory=datetime.now)
    creado_por: str = ""
    
    # Estado general
    estado_expediente: str = "en_proceso"  # en_proceso, listo, enviado, cerrado
    
    class Settings:
        name = "proyectos_versionados"
    
    def obtener_folio_actual(self) -> str:
        """Retorna folio con versión actual"""
        return f"{self.folio_base}-v{self.version_actual}"
    
    def obtener_version(self, numero: int) -> Optional[VersionExpediente]:
        """Obtiene una versión específica"""
        for v in self.versiones:
            if v.numero_version == numero:
                return v
        return None
    
    def obtener_ultima_version(self) -> Optional[VersionExpediente]:
        """Obtiene la versión más reciente"""
        if self.versiones:
            return max(self.versiones, key=lambda v: v.numero_version)
        return None


# =============================================================================
# FUNCIONES HELPER
# =============================================================================

def generar_folio_base(
    rfc: str,
    proyecto_id: str,
    fecha: datetime = None
) -> str:
    """Genera folio base sin versión"""
    fecha = fecha or datetime.now()
    timestamp = fecha.strftime("%Y%m%d")
    rfc_suffix = (rfc[-4:] if rfc else "XXXX").upper()
    id_suffix = str(proyecto_id)[-4:].zfill(4)
    
    return f"DUR-{timestamp}-{rfc_suffix}-{id_suffix}"


def generar_hash_contenido(datos: Dict[str, Any]) -> str:
    """Genera hash SHA-256 del contenido para verificar integridad"""
    contenido = json.dumps(datos, sort_keys=True, default=str)
    return hashlib.sha256(contenido.encode()).hexdigest()


def crear_entrada_bitacora(
    usuario: str,
    tipo: TipoCambio,
    titulo: str,
    descripcion: str,
    **kwargs
) -> EntradaBitacora:
    """Helper para crear entradas de bitácora"""
    return EntradaBitacora(
        usuario=usuario,
        tipo_cambio=tipo,
        titulo=titulo,
        descripcion=descripcion,
        **kwargs
    )

üöÄ PROMPT 15 (REVISADO): Pre-carga RAG en Paralelo
TAREA: Implementar SOLO pre-carga de RAG en paralelo (optimizaci√≥n segura que NO altera la cadena deliberativa).

En backend/services/deliberation_orchestrator.py:

PASO 1: Agrega estos imports al inicio del archivo:

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

PASO 2: Crea esta funci√≥n NUEVA (agr√©gala ANTES de la funci√≥n principal de orquestaci√≥n):

def preload_rag_contexts_parallel(project_data: Dict) -> Dict[str, str]:
    """
    Pre-carga contextos RAG de TODOS los agentes EN PARALELO usando threads
    Reduce latencia de ~2s√ó5 agentes = 10s a ~2s total
    """
    from services.rag_repository import RAGRepository
    
    rag = RAGRepository()
    agent_names = ["A1_SPONSOR", "A3_FISCAL", "A5_FINANZAS", "LEGAL", "A2_PMO"]
    
    def fetch_context(agent_name: str) -> tuple:
        """Fetch individual de contexto RAG"""
        try:
            query = f"{project_data.get('title', '')} {project_data.get('description', '')}"
            context = rag.query(collection_name=f"{agent_name}_knowledge", query_text=query, top_k=3)
            logger.info(f"‚úÖ RAG context loaded for {agent_name}")
            return (agent_name, context)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è No RAG context for {agent_name}: {e}")
            return (agent_name, "")
    
    # Ejecutar queries RAG en paralelo con ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=5) as executor:
        results = list(executor.map(fetch_context, agent_names))
    
    return dict(results)

PASO 3: En la funci√≥n principal de orquestaci√≥n, AL INICIO (antes de ejecutar cualquier agente), agrega:

# Pre-carga de contextos RAG en paralelo
logger.info("üöÄ Pre-loading RAG contexts in parallel...")
start_time = datetime.now()
rag_contexts = preload_rag_contexts_parallel(project_data)
elapsed = (datetime.now() - start_time).total_seconds()
logger.info(f"‚úÖ Loaded {len(rag_contexts)} RAG contexts in {elapsed:.2f}s (paralelo)")

PASO 4: Cuando ejecutes cada agente, PASA el contexto pre-cargado.

BUSCA donde llamas a los agentes (algo como agent.reason_about_project(...)):

ANTES:

a1_result = a1_agent.reason_about_project(project_data, previous_deliberations=[])

DESPU√âS:

a1_result = a1_agent.reason_about_project(
    project_data, 
    previous_deliberations=[],
    rag_context=rag_contexts.get("A1_SPONSOR", "")
)

Repite para TODOS los agentes (A1, A3, A5, LEGAL, A2_PMO).

IMPORTANTE:

NO cambies el orden de ejecuci√≥n de los agentes
NO uses asyncio/await (usamos ThreadPoolExecutor que es m√°s simple)
Los agentes siguen ejecut√°ndose SECUENCIALMENTE (solo el RAG se pre-carga en paralelo)
Mu√©strame:

¬øSe cre√≥ la funci√≥n preload_rag_contexts_parallel?
¬øSe llama al inicio del orquestador?
¬øTodos los agentes reciben rag_context del dict pre-cargado?
¬øHay errores de sintaxis?
¬øCu√°nto tiempo tard√≥ antes vs despu√©s? (revisa los logs)